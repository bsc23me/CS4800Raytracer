// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture => CameraRaytracer.Render(): line 3 

// Output RenderTexture
RWTexture2D<float4> Result;

#define MAX_BOUNCES 3
#define PI 3.14159265
#define CHECKERBOARD_SCALE 0.5

// Camera projection matricies
float4x4 CameraToWorldMat;
float4x4 InversePerspectiveProjMat;

int SAMPLES;

bool sunLight;
float4 Sun;

uint randomState = 2;

////////////////////////////////////////////////////////////////////////
// Random Functions
////////////////////////////////////////////////////////////////////////


// PCG (permuted congruential generator)
// Thanks to: www.youtube.com/@SebastianLague
// www.pcg-random.org and www.shadertoy.com/view/XlGcRh
float random(inout uint seed){
	seed = seed * 747796405 + 2891336453;
	uint result = ((seed >> ((seed >> 28) + 4)) ^ seed) * 277803737;
	result = (result >> 22) ^ result;
	return result / 4294967295.0;
}

float randomNormal(inout uint seed){
	float theta = 2 * 3.14159 * random(seed);
	float rho = sqrt(-2 * log(random(seed)));
	return rho * cos(theta);
}

float3 randomDirection(inout uint seed, float3 normal){
	float x = randomNormal(seed);
	float y = randomNormal(seed);
	float z = randomNormal(seed);
	float3 v = normalize(float3(x,y,z));
	float dotp = dot(v,normal);
	return v * sign(dotp);
}

////////////////////////////////////////////////////////////////////////
// Structures
////////////////////////////////////////////////////////////////////////

struct PMaterial{
	float3 albedo;
	float smoothness;
	float metalic;
	float3 emission;
	float emissionStrength;
};

struct HitInfo
{
	float3 hitPoint;
	float3 normal;
	float distance;
	float3 albedo;
	float smoothness;
	float metalic;
	float3 emission;
	float emissionStrength;
};

// Ray Structure
struct Ray
{
	float3 origin;
	float3 direction;
	float3 energy;
};

struct Sphere
{
	float3 center;
	float radius;
	PMaterial material;
};

struct Plane
{
	float3 position;
	float3 normal;
	PMaterial material;
};

struct Triangle{
	int3 points;
	int3 uv;
	int normal;
};

StructuredBuffer<Sphere> spheres;
StructuredBuffer<float3> Vertices;
StructuredBuffer<float3> VNormals;
StructuredBuffer<float2> UVs;
StructuredBuffer<Triangle> Meshes;
StructuredBuffer<int4> MeshIndex;

Texture2D<float4> Tex;
Texture2D<float4> Norm;

////////////////////////////////////////////////////////////////////////
// Structure Factories
////////////////////////////////////////////////////////////////////////

Ray CreateRay(float3 origin, float3 direction){
	Ray ray;
	ray.origin = origin;
	ray.direction = direction;
	ray.energy = float3(1.0, 1.0, 1.0);
	return ray;
}

Ray CreateCameraRay(float2 uv){
	float3 origin = mul(CameraToWorldMat, float4(0.0, 0.0, 0.0, 1.0)).xyz;
	float3 direction = mul(InversePerspectiveProjMat, float4(uv, 0.0, 1.0)).xyz;
	direction = mul(CameraToWorldMat, float4(direction,0.0)).xyz;
	direction = normalize(direction);
	return CreateRay(origin, direction);
}

HitInfo CreateRayHit(){
    HitInfo hit;
    hit.hitPoint = float3(0.0, 0.0, 0.0);
    hit.distance = 1.#INF;
    hit.normal = float3(0.0, 0.0, 0.0);
    hit.albedo = float3(0.0, 0.0, 0.0);
    hit.emission = float3(0.0, 0.0, 0.0);
	hit.emissionStrength = 0;
	hit.metalic = 0.0;
	hit.smoothness = 0.0;
    return hit;
}

/*

Sphere CreateSphere(float3 position, float radius){
	Sphere sphere;
	sphere.center = position;
	sphere.radius = radius;
	sphere.material.albedo = 1;
	sphere.material.emission = 0;
	sphere.material.emissionStrength = 0;
	return sphere;
}

Triangle CreateTriangle(float3 a, float3 b, float3 c){
	Triangle tri;
	tri.ptA = a;
	tri.ptB = b;
	tri.ptC = c;
	tri.normal = cross(c-a,b-a);
	tri.material.albedo = float3(0,1,0);
	tri.material.emission = 0;
	tri.material.emissionStrength = 0;
	tri.material.smoothness = 0.8;
	tri.material.metalic = 0;
	return tri;
}

*/

Plane CreatePlane(float3 position, float3 normal){
	Plane plane;
	plane.position = position;
	plane.normal = normal;
	//plane.material.albedo = 1;
	plane.material.emission = 1;
	plane.material.emissionStrength = 1;
	plane.material.smoothness = 0;
	plane.material.metalic = 0;
	return plane;
}



////////////////////////////////////////////////////////////////////////
// Triangle Helper Functions
////////////////////////////////////////////////////////////////////////

float TriangleArea(float3 ptA, float3 ptB, float3 ptC){
	float a = length(ptA - ptB);
	float b = length(ptA - ptC);
	float c = length(ptB - ptC);
	float s = (a + b + c) / 2;
	float area = sqrt(s*(s - a)*(s - b)*(s - c));
	return area;
}

float TriangleArea(Triangle tri){
	return TriangleArea(Vertices[tri.points.x], Vertices[tri.points.y], Vertices[tri.points.z]);
}

// Converts a given Cartesian point to the provided triangle specific Barycenteric coordinates
float3 CartToBary(Triangle tri, float3 cart)
{
	float3 x = Vertices[tri.points.x];
	float3 y = Vertices[tri.points.y];
	float3 z = Vertices[tri.points.z];
	float abc = TriangleArea(x,y,z);
	float alpha = TriangleArea(y, z, cart) / abc;
	float beta = TriangleArea(x, z, cart) / abc;
	float gamma = TriangleArea(x, y, cart) / abc;
	return float3(alpha,beta,gamma);
}

float2 BaryToUV(Triangle tri, int index, float3 bary){
	float2 a = UVs[index + tri.uv.x];
	float2 b = UVs[index + tri.uv.y];
	float2 c = UVs[index + tri.uv.z];
	return a*bary.x +b*bary.y+c*bary.z;
}

// Returns true if a given Cartesian point is inside a triangle
bool PointInTri(Triangle tri, float3 p)
{
	float3 baryPoint = CartToBary(tri, p);

	// account for floating point error
	float x = baryPoint.x + baryPoint.y + baryPoint.z - 1;
	return abs(x) < 0.001; // Try higher or lower to get better results (higher seemed to be better so far)

	//return baryPoint.x + baryPoint.y + baryPoint.z == 1;
}

////////////////////////////////////////////////////////////////////////
// Collision Detection Functions
////////////////////////////////////////////////////////////////////////

void updateHitMaterial(inout HitInfo hit, PMaterial mat, float2 uv){
	hit.albedo = mat.albedo;
	hit.smoothness = mat.smoothness;
	hit.metalic = mat.metalic;
	hit.emission = mat.emission;
	hit.emissionStrength = mat.emissionStrength;
}

// Renders a basic Skybox
float3 SkyboxIntersect(Ray ray){
	// looking at the sun
	/*if(dot(ray.direction,-Sun.xyz) > 0.999) // => 0.999 determines the size of the sun: x => 0 sun fills sky | x => 1 sun shrinks to point
		return 1; // sun is pure white
		*/

	// looking above horizon
	float y = ray.direction.y; // V sky is gradient from dark to light | V ground is mid gray
	float3 sky = y > 0 ? float3(0.4*(1-y)*(1-y), 0.8*(1-y)*(1-y), 1.0) : 0.4;

	float sun = pow(max(0, dot(ray.direction,-Sun.xyz)), 32);
	return lerp(sky, 1, sun);
}

//Determines whether a plane was hit using an arbitrary point on the plane
//((P + td) - Q) * N = 0
void PlaneIntersect(Ray ray, Plane plane, inout HitInfo hit){
	float3 v = plane.position - ray.origin; // stored surface point commutation X = ((P + td) - Q) => ((P - Q) + td) => v + td
	float d = dot(ray.direction, plane.normal); // N * d 
	if(d < 0){ // d != 0 => prevent division by 0; d < 0 => backface culling
		float t = dot(v, plane.normal) / d;
		if(t > 0 && t < hit.distance){ 
			// update all the hit information with the planes data
			hit.hitPoint = ray.origin + t * ray.direction;
			hit.normal = plane.normal;
			hit.distance = t;
			//updateHitMaterial(hit, plane.material, 0);
			hit.albedo = int(bool(floor(CHECKERBOARD_SCALE * hit.hitPoint.x) % 2) ^ bool(floor(CHECKERBOARD_SCALE * hit.hitPoint.z) % 2));
		}
	}
}

void TriangleIntersect(Ray ray, Triangle tri, int4 indices, inout HitInfo hit){
	uint w, h;
	Tex.GetDimensions(w,h);
	//float3 normal = -cross(tri.ptC - tri.ptA, tri.ptB - tri.ptA);
	float3 normal = VNormals[indices.y + tri.normal];
	float3 v = Vertices[indices.x + tri.points.x] - ray.origin;
	float d = dot(ray.direction, normal);
	float occ = dot(ray.direction, normalize(v));
	if(d != 0 /*&& occ > 0*/){
		float t = dot(v, normal) / d;
		float3 p = ray.origin + t * ray.direction;
		if(t > 0 && t < hit.distance){
			float3 bary = CartToBary(tri, p);
			if(abs(bary.x + bary.y + bary.z - 1) < 0.001){
				float2 uv = BaryToUV(tri,indices.z,bary);
				int2 texSpace = int2(uv.x * w, uv.y * h);
				hit.hitPoint = p;
				hit.normal = normal + Norm[texSpace];
				hit.distance = t;
				hit.albedo = Tex[texSpace];
				hit.smoothness = 0;
				//updateHitMaterial(hit, tri.material, 0);
			}
		}
	}
}

// Determines whether a sphere was hit by defining a point on the sphere
// X which is a distance r away from the center is also equal to the ray point (ray.origin + ray.direction * t)
// ((P + td) - Q) * ((P + td) - Q)) = r^2
void SphereIntersect(Ray ray, Sphere sphere, inout HitInfo hit){
	float3 v = ray.origin - sphere.center; // stored surface point commutation X = ((P + td) - Q) => ((P - Q) + td) => v + td
	float a = dot(ray.direction, ray.direction); // quadratic term
	if(a == 0) // prevent division by 0
		return;
	float b = 2.0 * dot(ray.direction,v); // linear term
	float c = dot(v,v) - sphere.radius * sphere.radius; // constant term
	float t1 = (-b - sqrt(b*b-4*a*c)) / 2*a; // solve for parameter t using the quadratic formula
	if(t1 > 0 && t1 < hit.distance){ // compare the sphere intersection to the rays current closest hit => closer ? update : keep
		// update all the hit information with the spheres data
		hit.hitPoint = ray.origin + t1 * ray.direction;
		hit.normal = normalize(hit.hitPoint - sphere.center);
		hit.distance = t1;
		hit.smoothness = sphere.material.smoothness;
		updateHitMaterial(hit, sphere.material, 0);
	}
}

//////////////////////////////////////////////////////////////////////////
// General Helper Functions
//////////////////////////////////////////////////////////////////////////


Ray Bounce(Ray ray, HitInfo hit, inout uint seed){
	if(hit.distance < 1.#INF){
		ray.origin = hit.hitPoint + hit.normal * 0.001;
		float3 diffuseRay = normalize(hit.normal + randomDirection(seed, hit.normal));
		float3 specularRay = reflect(ray.direction, hit.normal);

		ray.direction = lerp(diffuseRay, specularRay, hit.smoothness);
	}
	return ray;
}



HitInfo RayCollision(Ray ray){
	HitInfo hit = CreateRayHit();
	PlaneIntersect(ray, CreatePlane(float3(0.0, -2.0, 0.0),float3(0.0, 1.0, 0.0)), hit); // Ground plane hit
	// Scene Spheres
	uint sphereCount, stride;
	spheres.GetDimensions(sphereCount, stride);
	for(uint i = 0; i < sphereCount; i++){
		//SphereIntersect(ray,spheres[i],hit);
	}
	uint meshCount, meshStride;
	uint triCount, triStride;
	MeshIndex.GetDimensions(meshCount, meshStride);
	Meshes.GetDimensions(triCount, triStride);
	int currMesh = 0;
	for(uint i = 0; i < meshCount; i++){
		for(uint j = 0; j < MeshIndex[i].w; j++){
			TriangleIntersect(ray,Meshes[i+j],MeshIndex[i],hit);
		}
	}

	return hit;
}

///////////////////////////////////////////////////////////
// Main Computations
///////////////////////////////////////////////////////////

// Fires a given ray and returns color based on the combined hits
// associated with the intersections in the scene
float3 FireRay(Ray ray, inout uint seed){
	float3 color = 1;
	float energy = 1;
	int bounces = 1;
	while(bounces <= MAX_BOUNCES){
		HitInfo hit = RayCollision(ray); // Check ray collisions
		if(hit.distance < 1.#INF){

			// Bounce Ray
			ray = Bounce(ray, hit, seed);

			

			// Compute Shadows
			float3 light = sunLight ? -1*Sun.xyz : normalize(float3(0,10,0) - hit.hitPoint); // use directional sunlight or point light

			Ray shadowRay = CreateRay(hit.hitPoint + hit.normal * 0.001, light); // fire ray toward light source
			HitInfo shadowHit = RayCollision(shadowRay); // check shadow ray collisions

			if(shadowHit.distance != 1.#INF){ // if the light is blocked
				color *= 0.05 * hit.albedo; // the point is in shadow
			}
			else{ // ray is in direct light

				float3 diffuse = max(0.05,saturate(dot(light, hit.normal))) * Sun.w * hit.albedo;

				float s = pow(8192, min(max(0.1,hit.smoothness),0.9));
				float glossy = pow(max(0, dot(light, hit.normal)), s);
				

				color = lerp(color, diffuse, energy);
				
				float3 specular = lerp(diffuse, 1, glossy); // 
				/*color = (hit.albedo / PI) + ((8 + s)/(8 * PI)) * (1 - hit.albedo) * specular;
				color = max(0.05,saturate(-dot(Sun.xyz, hit.normal))) * Sun.w * color;*/
				/*ray = Bounce(ray,hit,seed);
				
				PMaterial mat = hit.material;
				incomingLight += (color * mat.emission) * mat.emissionStrength;
				color *= mat.albedo;*/
				/*if(!any(energy))
					break;*/
				
			}

			energy *= hit.smoothness;
			if(energy < 0.001)
				break;
			
		}
		else{
			color = lerp(color, SkyboxIntersect(ray), energy);
			break;
		}
		bounces++;
	}
	//color /= bounces;
	return color;
}



float3 Shade(inout Ray ray, HitInfo hit, inout uint seed){
	if(hit.distance < 1.#INF){
		ray.origin = hit.hitPoint + hit.normal * 0.001;
		float3 diffuseRay = normalize(hit.normal + randomDirection(seed, hit.normal));
		float3 specularRay = reflect(ray.direction, hit.normal);

		ray.direction = lerp(diffuseRay, specularRay, hit.smoothness);


		/*
		ray.energy *= hit.specular;
		Ray shadowRay = CreateRay(hit.hitPoint + hit.normal * 0.001, -1*Sun.xyz);
		HitInfo shadowHit = FireRay(shadowRay);
		if(shadowHit.distance != 1.#INF){
			return 0.05 * hit.albedo;
		}
		
		//float3 color = hit.albedo * hit.specular;
		return saturate((-dot(Sun.xyz, hit.normal)) + 0.05) * Sun.w * hit.albedo;*/
	}else{
		ray.energy = 0.0;
		return SkyboxIntersect(ray);
	}
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	uint width, height;
	Result.GetDimensions(width,height);
	uint index = (id.x + id.y * width);
	uint rngState = index;
	float2 uv = float2((id.xy) / float2(width,height) * 2.0 - 1.0);

	Ray camRay = CreateCameraRay(uv);
	float3 randRay = randomDirection(rngState, camRay.direction);
	float3 dir = lerp(camRay.direction, randRay, 0.0003);
	Ray ray = CreateRay(camRay.origin, dir);
	//float3 color = float4(0.4,0.58,0.93,1.0);
	float3 color = 0;
	for(int i = 0; i < SAMPLES; i++){
		color += FireRay(ray,rngState);
	}
	color /= SAMPLES;

    Result[id.xy] = float4(color, 1);
    //Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
    //Result[id.xy] = float4(0.4,0.58,0.93,1.0);
	//Result[id.xy] = float4(random(index),1);
	//Result[id.xy] = float4(ray.direction, 1);
}
